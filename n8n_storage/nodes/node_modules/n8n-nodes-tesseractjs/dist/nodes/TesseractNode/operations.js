"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.performOCR = performOCR;
exports.extractBoxes = extractBoxes;
const timers_1 = require("timers");
async function withTimeout(promise, timeout, cleanupFunc) {
    if (!timeout)
        return promise;
    return Promise.race([
        promise,
        new Promise((resolve) => (0, timers_1.setTimeout)(async () => {
            if (cleanupFunc)
                await cleanupFunc();
            resolve("timeout");
        }, timeout))
    ]);
}
async function performOCR(worker, item, itemIndex, imageFieldName, bbox, timeout = 0) {
    const newItem = {
        json: {},
        binary: item.binary,
        pairedItem: item.index
    };
    const data = await this.helpers.getBinaryDataBuffer(itemIndex, imageFieldName);
    const d = await withTimeout(worker.recognize(data, { rectangle: bbox }, { text: true }), timeout, async () => {
        await worker.terminate();
    });
    newItem.json =
        d === "timeout" ?
            { timeout: true } :
            { text: d.data.text, confidence: d.data.confidence };
    return newItem;
}
async function extractBoxes(worker, item, itemIndex, imageFieldName, granularity, bbox, timeout = 0) {
    const newItem = {
        json: {},
        binary: item.binary,
        pairedItem: itemIndex
    };
    const data = await this.helpers.getBinaryDataBuffer(itemIndex, imageFieldName);
    const d = await withTimeout(worker.recognize(data, { rectangle: bbox }, { blocks: true }), timeout, async () => {
        await worker.terminate();
    });
    if (d === "timeout") {
        newItem.json = { timeout: true };
    }
    else {
        d.data.paragraphs = d.data.blocks.map((block) => block.paragraphs).flat();
        d.data.lines = d.data.blocks.map((block) => block.paragraphs.map((paragraph) => paragraph.lines)).flat(2);
        d.data.words = d.data.blocks.map((block) => block.paragraphs.map((paragraph) => paragraph.lines.map((line) => line.words))).flat(3);
        d.data.symbols = d.data.blocks.map((block) => block.paragraphs.map((paragraph) => paragraph.lines.map((line) => line.words.map((word) => word.symbols)))).flat(4);
        newItem.json = {
            blocks: d.data[granularity].map((b) => ({
                text: b.text,
                confidence: b.confidence,
                bbox: b.bbox,
                language: "language" in b ? b.language : undefined
            }))
        };
    }
    return newItem;
}
//# sourceMappingURL=operations.js.map